/*中值滤波
描述:中值滤波是对一个滑动窗口内的值进行排序，用其中值代替窗口中心点的原来值的滤波方法，它在抑制随机噪声的同时能有效保护原有信息。以一维信号的中值滤波举例。
对序列 80 120 90 200 100 110 150，假设滤波窗口宽度为5,那么有
滤波窗口的子序列     子序列排序              待替换的值   序列中值
80 120 90 200 100   80 90 10O 120 200            90          100
120 90 200 100 110  90 100 110 120 200           200         110
90 200 100 110 150  90 100 110 150 200           100         110
滤波窗口的值如果不够5个值那么不改变对应点的值， 比如左侧的80， 以它为中心的5个长度的窗口内没有5个数，所以这个点仍然是80不变。
所以最后滤波结果是80 120 100 110 110 110 150。
如果滤波窗口宽度为3，那么滤波结果是80 90 120 100 110 110 150。
输入:可能包含多组数据。每组数据包括2行。第一行为2个整数w、n，w为滤波窗口宽度（必须是奇数），n表示后面有n个整数。第二行为待滤波的n个整数，各数之间用一个空格来间隔。
输出:输出滤波后的序列，各数之间用一个空格分隔，输出需占一行，结尾需换行。如果输入w不是奇数那么输出ERROR。*/
#include <stdio.h>
#include <string.h>
void sort(int a[],int n)
{
	int i,j;
	for(i=0;i<n-1;i++)
	   for(j=0;j<n-1-i;j++)
	   {
	   	if(a[j]>a[j+1])
	   	{
	   		int temp;
	   		temp=a[j];
	   		a[j]=a[j+1];
	   		a[j+1]=temp;
		   }
	   }
}
int main(void)
{
	int w,n;
	while(scanf("%d %d",&w,&n)!=EOF)
	{
		
			int i;
			int digit[100],b[100],c[100];
			for(i=0;i<n;i++)
			{
				scanf("%d",&digit[i]);
				b[i]=digit[i];
			}
			if(w%2==0)
		{
			printf("ERROR\n");
		}
			else {
			int m,k,t;
			for(m=0;m<n-w+1;m++)
			{
				t=0;
				for(k=m;k<m+w;k++)
				{
					c[t]=b[k];
					t++;
				 }
				 sort(c,w);
				 digit[m+(w-1)/2]=c[(w-1)/2]; 
			}
			for(i=0;i<n;i++)
			{
				printf("%d ",digit[i]);
			}
			printf("\n");
		}
		memset(digit, 0, digit[0]);
		
	}
	return 0;
}

